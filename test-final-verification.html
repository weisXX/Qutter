<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>最终验证修复效果</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .test-case {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .input {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 3px;
            margin-bottom: 10px;
            font-family: monospace;
            white-space: pre-wrap;
        }
        .output {
            background: #e8f4f8;
            padding: 10px;
            border-radius: 3px;
            margin-bottom: 10px;
            min-height: 50px;
        }
        .status {
            padding: 5px 10px;
            border-radius: 3px;
            font-weight: bold;
        }
        .success {
            background: #d4edda;
            color: #155724;
        }
        .failure {
            background: #f8d7da;
            color: #721c24;
        }
        h3 {
            margin-top: 0;
            color: #333;
        }
        .debug {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 3px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 12px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <h1>最终验证修复效果</h1>
    <p>测试 EnhancedMarkdownRenderer.vue 中的修复：</p>
    <ol>
        <li>将 <code>breaks: true</code> 改为 <code>breaks: false</code> 以避免干扰数学公式</li>
        <li>改进预处理逻辑，保护数学公式区域不被破坏</li>
    </ol>
    
    <div class="test-case">
        <h3>原始问题1: \text{} 被转义成 \cdotp</h3>
        <div class="input">
            <strong>测试内容:</strong> $\text{hello world}$
        </div>
        <div class="output" id="test1-output"></div>
        <div class="debug">
            <strong>检查点:</strong> 输出中是否包含 "hello world" 文本？是否包含点乘符号 "⋅" 或 "\cdotp"？
        </div>
        <div id="test1-status" class="status"></div>
    </div>
    
    <div class="test-case">
        <h3>原始问题2: \[ 和 \] 中的换行符问题</h3>
        <div class="input">
            <strong>测试内容:</strong> \[<br>f(x) = x^2<br>\]
        </div>
        <div class="output" id="test2-output"></div>
        <div class="debug">
            <strong>检查点:</strong> 是否成功渲染为块级公式？换行符是否被正确处理？
        </div>
        <div id="test2-status" class="status"></div>
    </div>
    
    <div class="test-case">
        <h3>综合测试: 混合内容</h3>
        <div class="input">
            <strong>测试内容:</strong> 普通文本<br>然后行内公式 $\text{测试}$<br>最后块级公式 \[<br>a^2 + b^2 = c^2<br>\]
        </div>
        <div class="output" id="test3-output"></div>
        <div class="debug">
            <strong>检查点:</strong> 所有内容是否正常渲染？数学公式是否正确？
        </div>
        <div id="test3-status" class="status"></div>
    </div>
    
    <div class="test-case">
        <h3>边界测试: 多个公式</h3>
        <div class="input">
            <strong>测试内容:</strong> $\text{第一个}$ 和 $\text{第二个}$ 公式 \[<br>x = y<br>\] 结束
        </div>
        <div class="output" id="test4-output"></div>
        <div id="test4-status" class="status"></div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/markdown-it@14.1.0/dist/markdown-it.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/markdown-it-texmath@1.0.0/dist/markdown-it-texmath.min.js"></script>
    
    <script>
        // 修复后的配置
        const md = window.markdownit({
            html: true,
            linkify: true,
            typographer: true,
            breaks: false  // 关键修复
        });
        
        md.use(window.markdownitTexmath, {
            engine: window.katex,
            delimiters: ['dollars', 'brackets'],
            katexOptions: {
                throwOnError: false,
                errorColor: '#cc0000',
                strict: false
            }
        });
        
        // 修复后的预处理逻辑
        function preprocessContent(content) {
            // 保护数学公式区域
            const formulaRegex = /(\$\$.*?\$\$|\\\[.*?\\\]|\\\(.*?\\\)|\$.*?\$)/gs
            const parts = []
            let lastIndex = 0
            let match
            
            while ((match = formulaRegex.exec(content)) !== null) {
                // 添加公式前的文本
                if (match.index > lastIndex) {
                    const textBefore = content.slice(lastIndex, match.index)
                    parts.push(textBefore
                        .replace(/<br[^>]*>/g, '\n')
                        .replace(/&nbsp;/g, ' ')
                    )
                }
                // 添加公式本身（不进行任何处理）
                parts.push(match[0])
                lastIndex = formulaRegex.lastIndex
            }
            
            // 添加最后一段文本
            if (lastIndex < content.length) {
                const textAfter = content.slice(lastIndex)
                parts.push(textAfter
                    .replace(/<br[^>]*>/g, '\n')
                    .replace(/&nbsp;/g, ' ')
                )
            }
            
            if (parts.length === 0) {
                return content
                    .replace(/<br[^>]*>/g, '\n')
                    .replace(/&nbsp;/g, ' ')
            } else {
                return parts.join('')
            }
        }
        
        // 测试用例
        const tests = [
            {
                id: 'test1',
                input: '$\\text{hello world}$',
                check: (output) => {
                    const hasText = output.includes('hello world');
                    const hasCdotp = output.includes('⋅') || output.includes('\\cdotp');
                    return {
                        passed: hasText && !hasCdotp,
                        message: hasText ? 
                            (hasCdotp ? '包含点乘符号，失败' : '正确显示文本，成功') :
                            '未找到期望文本'
                    };
                }
            },
            {
                id: 'test2',
                input: '\\[<br>f(x) = x^2<br>\\]',
                check: (output) => {
                    const hasFormula = output.includes('x^2') || output.includes('x²');
                    const isBlock = output.includes('<section') || output.includes('display');
                    return {
                        passed: hasFormula && isBlock,
                        message: hasFormula ?
                            (isBlock ? '正确渲染为块级公式，成功' : '未正确渲染为块级公式') :
                            '未找到公式'
                    };
                }
            },
            {
                id: 'test3',
                input: '普通文本<br>然后行内公式 $\\text{测试}$<br>最后块级公式 \\[<br>a^2 + b^2 = c^2<br>\\]',
                check: (output) => {
                    const hasInlineText = output.includes('测试');
                    const hasBlockFormula = output.includes('c^2') || output.includes('c²');
                    const hasNormalText = output.includes('普通文本');
                    return {
                        passed: hasInlineText && hasBlockFormula && hasNormalText,
                        message: `行内公式: ${hasInlineText ? '✓' : '✗'}, 块级公式: ${hasBlockFormula ? '✓' : '✗'}, 普通文本: ${hasNormalText ? '✓' : '✗'}`
                    };
                }
            },
            {
                id: 'test4',
                input: '$\\text{第一个}$ 和 $\\text{第二个}$ 公式 \\[<br>x = y<br>\\] 结束',
                check: (output) => {
                    const hasFirst = output.includes('第一个');
                    const hasSecond = output.includes('第二个');
                    const hasBlock = output.includes('x = y');
                    return {
                        passed: hasFirst && hasSecond && hasBlock,
                        message: `第一个: ${hasFirst ? '✓' : '✗'}, 第二个: ${hasSecond ? '✓' : '✗'}, 块级: ${hasBlock ? '✓' : '✗'}`
                    };
                }
            }
        ];
        
        // 运行所有测试
        tests.forEach(test => {
            try {
                const processed = preprocessContent(test.input);
                const output = md.render(processed);
                document.getElementById(`${test.id}-output`).innerHTML = output;
                
                const result = test.check(output);
                const statusEl = document.getElementById(`${test.id}-status`);
                statusEl.textContent = result.message;
                statusEl.className = `status ${result.passed ? 'success' : 'failure'}`;
                
                console.log(`测试 ${test.id}:`, result.passed ? '通过' : '失败', result.message);
                console.log('输入:', test.input);
                console.log('输出:', output);
                
            } catch (error) {
                document.getElementById(`${test.id}-output`).innerHTML = 
                    `<span style="color: red">错误: ${error.message}</span>`;
                document.getElementById(`${test.id}-status`).className = 'status failure';
                document.getElementById(`${test.id}-status`).textContent = `错误: ${error.message}`;
                console.error(`测试 ${test.id} 错误:`, error);
            }
        });
        
        console.log('所有测试完成');
        console.log('修复总结:');
        console.log('1. 将 markdown-it 的 breaks 选项设为 false，避免自动转换换行符干扰数学公式');
        console.log('2. 改进预处理逻辑，保护数学公式区域不被 HTML 标签清理破坏');
        console.log('3. 只对非公式区域进行 <br> 标签替换');
    </script>
</body>
</html>